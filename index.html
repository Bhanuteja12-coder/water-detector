<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Real-Time Object Detector</title>
<style>
  body { 
    background:#111; 
    color:#eee; 
    font-family:Arial; 
    text-align:center; 
    margin:0;
    padding:20px;
  }
  #videoContainer {
    position: relative;
    display: inline-block;
    margin-top: 20px;
  }
  video { 
    width:100%; 
    max-width:640px; 
    border:3px solid #0ff; 
    border-radius:10px;
    display: block;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  #status { 
    margin-top:20px; 
    font-size:20px; 
    color: #0ff;
  }
  #detections {
    margin-top: 20px;
    padding: 20px;
    background: #222;
    border-radius: 10px;
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
  }
  .detection-item {
    padding: 10px;
    margin: 5px 0;
    background: #333;
    border-radius: 5px;
    font-size: 18px;
  }
  .object-name {
    color: #0ff;
    font-weight: bold;
  }
  .confidence {
    color: #0f0;
    font-size: 14px;
  }
</style>
</head>
<body>
<h2>ğŸ¯ Real-Time Object Detector</h2>

<div id="status">Loading AI model...</div>

<div id="videoContainer">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
</div>

<div id="detections"></div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>

<script>
(async () => {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");
    const detectionsDiv = document.getElementById("detections");
    
    let cocoModel = null;
    let mobileNetModel = null;

    // Start webcam with back camera
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: { ideal: "environment" },
                width: { ideal: 640 },
                height: { ideal: 480 }
            } 
        });
        video.srcObject = stream;
        
        video.addEventListener('loadeddata', () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        });
        
    } catch (e) {
        status.textContent = "âŒ Camera error: " + e.message;
        return;
    }

    // Load both models for better detection
    try {
        status.textContent = "ğŸ¤– Loading AI models (20-30 seconds)...";
        
        // Load COCO-SSD for object detection
        cocoModel = await cocoSsd.load({
            base: 'mobilenet_v2'
        });
        
        // Load MobileNet for image classification (detects 1000+ objects)
        mobileNetModel = await mobilenet.load({
            version: 2,
            alpha: 1.0
        });
        
        status.textContent = "âœ… AI Ready! Detecting 1000+ object types";
        status.style.color = "#0f0";
        detectObjects();
    } catch (e) {
        status.textContent = "âŒ Error loading models: " + e.message;
        return;
    }

    const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f00', '#00f', '#ffa500', '#ff69b4'];

    async function detectObjects() {
        if (!cocoModel || !mobileNetModel) return;

        // Get COCO detections (bounding boxes)
        const cocoDetections = await cocoModel.detect(video, undefined, 0.25);
        
        // Get MobileNet classifications (what the whole scene contains)
        const classifications = await mobileNetModel.classify(video, 5);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw bounding boxes
        ctx.font = "bold 16px Arial";
        ctx.lineWidth = 3;
        
        let detectionsHTML = "";
        let totalDetections = 0;
        
        // Draw COCO detections with boxes
        if (cocoDetections.length > 0) {
            cocoDetections.sort((a, b) => b.score - a.score);
            
            cocoDetections.forEach((prediction, index) => {
                const [x, y, width, height] = prediction.bbox;
                const confidence = (prediction.score * 100).toFixed(0);
                const color = colors[index % colors.length];
                
                // Draw box
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.strokeRect(x, y, width, height);
                
                // Draw label
                const label = `${prediction.class.toUpperCase()}`;
                const confLabel = `${confidence}%`;
                const textWidth = ctx.measureText(label).width;
                const confWidth = ctx.measureText(confLabel).width;
                
                ctx.fillStyle = color;
                ctx.fillRect(x, y - 30, Math.max(textWidth, confWidth) + 15, 30);
                
                ctx.fillStyle = "#000";
                ctx.fillText(label, x + 5, y - 12);
                ctx.font = "12px Arial";
                ctx.fillText(confLabel, x + 5, y - 2);
                ctx.font = "bold 16px Arial";
                
                const emoji = getEmoji(prediction.class);
                detectionsHTML += `
                    <div class="detection-item" style="border-left: 4px solid ${color};">
                        ${emoji} <span class="object-name">${prediction.class}</span> 
                        <span class="confidence">${confidence}%</span>
                    </div>
                `;
                totalDetections++;
            });
        }
        
        // Add MobileNet classifications (can detect cubes, shapes, etc.)
        if (classifications.length > 0) {
            detectionsHTML += '<div style="margin-top:15px; padding:10px; background:#1a1a1a; border-radius:5px;"><strong>ğŸ” Also detected in scene:</strong></div>';
            
            classifications.forEach((classification, index) => {
                const confidence = (classification.probability * 100).toFixed(0);
                if (confidence > 15) { // Show if >15% confidence
                    const color = colors[(cocoDetections.length + index) % colors.length];
                    detectionsHTML += `
                        <div class="detection-item" style="border-left: 4px solid ${color}; opacity:0.8;">
                            ğŸ¯ <span class="object-name">${classification.className}</span> 
                            <span class="confidence">${confidence}%</span>
                        </div>
                    `;
                    totalDetections++;
                }
            });
        }
        
        if (totalDetections === 0) {
            detectionsHTML = '<div class="detection-item" style="color:#888;">No objects detected - try different angle or better lighting</div>';
            status.textContent = "âŒ No objects detected";
        } else {
            status.textContent = `âœ… Detected ${totalDetections} object${totalDetections > 1 ? 's' : ''}`;
        }
        
        detectionsDiv.innerHTML = detectionsHTML;
        
        // Continue detection
        requestAnimationFrame(detectObjects);
    }

    function getEmoji(className) {
        const emojiMap = {
            'person': 'ğŸ‘¤', 'bicycle': 'ğŸš²', 'car': 'ğŸš—', 'motorcycle': 'ğŸï¸',
            'airplane': 'âœˆï¸', 'bus': 'ğŸšŒ', 'train': 'ğŸš†', 'truck': 'ğŸšš',
            'boat': 'â›µ', 'traffic light': 'ğŸš¦', 'stop sign': 'ğŸ›‘',
            'bench': 'ğŸª‘', 'bird': 'ğŸ¦', 'cat': 'ğŸ±', 'dog': 'ğŸ•',
            'horse': 'ğŸ´', 'sheep': 'ğŸ‘', 'cow': 'ğŸ„', 'elephant': 'ğŸ˜',
            'bear': 'ğŸ»', 'zebra': 'ğŸ¦“', 'giraffe': 'ğŸ¦’', 'backpack': 'ğŸ’',
            'umbrella': 'â˜‚ï¸', 'handbag': 'ğŸ‘œ', 'tie': 'ğŸ‘”', 'suitcase': 'ğŸ§³',
            'sports ball': 'âš½', 'bottle': 'ğŸ¾', 'cup': 'â˜•', 'fork': 'ğŸ´',
            'knife': 'ğŸ”ª', 'spoon': 'ğŸ¥„', 'bowl': 'ğŸ¥£', 'banana': 'ğŸŒ',
            'apple': 'ğŸ', 'sandwich': 'ğŸ¥ª', 'orange': 'ğŸŠ', 'pizza': 'ğŸ•',
            'donut': 'ğŸ©', 'cake': 'ğŸ°', 'chair': 'ğŸª‘', 'couch': 'ğŸ›‹ï¸',
            'bed': 'ğŸ›ï¸', 'toilet': 'ğŸš½', 'tv': 'ğŸ“º', 'laptop': 'ğŸ’»',
            'mouse': 'ğŸ–±ï¸', 'keyboard': 'âŒ¨ï¸', 'cell phone': 'ğŸ“±',
            'book': 'ğŸ“š', 'clock': 'ğŸ•', 'vase': 'ğŸº', 'scissors': 'âœ‚ï¸',
            'teddy bear': 'ğŸ§¸'
        };
        return emojiMap[className] || 'ğŸ“¦';
    }
})();
</script>
</body>
</html>
