<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Real-Time Object Detector</title>
<style>
  body { 
    background:#111; 
    color:#eee; 
    font-family:Arial; 
    text-align:center; 
    margin:0;
    padding:20px;
  }
  #videoContainer {
    position: relative;
    display: inline-block;
    margin-top: 20px;
  }
  video { 
    width:100%; 
    max-width:640px; 
    border:3px solid #0ff; 
    border-radius:10px;
    display: block;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  #status { 
    margin-top:20px; 
    font-size:20px; 
    color: #0ff;
  }
  #detections {
    margin-top: 20px;
    padding: 20px;
    background: #222;
    border-radius: 10px;
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
  }
  .detection-item {
    padding: 10px;
    margin: 5px 0;
    background: #333;
    border-radius: 5px;
    font-size: 18px;
  }
  .object-name {
    color: #0ff;
    font-weight: bold;
  }
  .confidence {
    color: #0f0;
    font-size: 14px;
  }
</style>
</head>
<body>
<h2>ğŸ¯ Real-Time Object Detector</h2>

<div id="status">Loading AI model...</div>

<div id="videoContainer">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
</div>

<div id="detections"></div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<script>
(async () => {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");
    const detectionsDiv = document.getElementById("detections");
    
    let model = null;

    // Start webcam with back camera
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: { ideal: "environment" },
                width: { ideal: 640 },
                height: { ideal: 480 }
            } 
        });
        video.srcObject = stream;
        
        video.addEventListener('loadeddata', () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        });
        
    } catch (e) {
        status.textContent = "âŒ Camera error: " + e.message;
        return;
    }

    // Load COCO-SSD model with base mobilenet_v2
    try {
        status.textContent = "ğŸ¤– Loading AI model (this may take 10-20 seconds)...";
        model = await cocoSsd.load({
            base: 'mobilenet_v2' // More accurate than default
        });
        status.textContent = "âœ… AI Ready! Point at objects (80+ types supported)";
        status.style.color = "#0f0";
        detectObjects();
    } catch (e) {
        status.textContent = "âŒ Error loading model: " + e.message;
        return;
    }

    const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f00', '#00f'];
    let colorIndex = 0;

    async function detectObjects() {
        if (!model) return;

        // Run detection with lower score threshold to detect more objects
        const predictions = await model.detect(video, undefined, 0.3); // 30% confidence threshold
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw bounding boxes and labels
        ctx.font = "bold 16px Arial";
        ctx.lineWidth = 3;
        
        let detectionsHTML = "";
        
        if (predictions.length === 0) {
            detectionsHTML = '<div class="detection-item" style="color:#888;">No objects detected - try moving camera closer</div>';
        } else {
            // Sort by confidence
            predictions.sort((a, b) => b.score - a.score);
            
            predictions.forEach((prediction, index) => {
                const [x, y, width, height] = prediction.bbox;
                const confidence = (prediction.score * 100).toFixed(0);
                const color = colors[index % colors.length];
                
                // Draw box
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.strokeRect(x, y, width, height);
                
                // Draw label background
                const label = `${prediction.class.toUpperCase()}`;
                const confLabel = `${confidence}%`;
                const textWidth = ctx.measureText(label).width;
                const confWidth = ctx.measureText(confLabel).width;
                
                ctx.fillStyle = color;
                ctx.fillRect(x, y - 30, Math.max(textWidth, confWidth) + 15, 30);
                
                // Draw label text
                ctx.fillStyle = "#000";
                ctx.fillText(label, x + 5, y - 12);
                ctx.font = "12px Arial";
                ctx.fillText(confLabel, x + 5, y - 2);
                ctx.font = "bold 16px Arial";
                
                // Add to list
                const emoji = getEmoji(prediction.class);
                detectionsHTML += `
                    <div class="detection-item" style="border-left: 4px solid ${color};">
                        ${emoji} <span class="object-name">${prediction.class}</span> 
                        <span class="confidence">${confidence}%</span>
                    </div>
                `;
            });
            
            status.textContent = `âœ… Detected ${predictions.length} object${predictions.length > 1 ? 's' : ''}`;
        }
        
        detectionsDiv.innerHTML = detectionsHTML;
        
        // Continue detection
        requestAnimationFrame(detectObjects);
    }

    function getEmoji(className) {
        const emojiMap = {
            'person': 'ğŸ‘¤',
            'bicycle': 'ğŸš²',
            'car': 'ğŸš—',
            'motorcycle': 'ğŸï¸',
            'airplane': 'âœˆï¸',
            'bus': 'ğŸšŒ',
            'train': 'ğŸš†',
            'truck': 'ğŸšš',
            'boat': 'â›µ',
            'traffic light': 'ğŸš¦',
            'fire hydrant': 'ğŸš’',
            'stop sign': 'ğŸ›‘',
            'parking meter': 'ğŸ…¿ï¸',
            'bench': 'ğŸª‘',
            'bird': 'ğŸ¦',
            'cat': 'ğŸ±',
            'dog': 'ğŸ•',
            'horse': 'ğŸ´',
            'sheep': 'ğŸ‘',
            'cow': 'ğŸ„',
            'elephant': 'ğŸ˜',
            'bear': 'ğŸ»',
            'zebra': 'ğŸ¦“',
            'giraffe': 'ğŸ¦’',
            'backpack': 'ğŸ’',
            'umbrella': 'â˜‚ï¸',
            'handbag': 'ğŸ‘œ',
            'tie': 'ğŸ‘”',
            'suitcase': 'ğŸ§³',
            'frisbee': 'ğŸ¥',
            'skis': 'ğŸ¿',
            'snowboard': 'ğŸ‚',
            'sports ball': 'âš½',
            'kite': 'ğŸª',
            'baseball bat': 'âš¾',
            'baseball glove': 'ğŸ¥',
            'skateboard': 'ğŸ›¹',
            'surfboard': 'ğŸ„',
            'tennis racket': 'ğŸ¾',
            'bottle': 'ğŸ¾',
            'wine glass': 'ğŸ·',
            'cup': 'â˜•',
            'fork': 'ğŸ´',
            'knife': 'ğŸ”ª',
            'spoon': 'ğŸ¥„',
            'bowl': 'ğŸ¥£',
            'banana': 'ğŸŒ',
            'apple': 'ğŸ',
            'sandwich': 'ğŸ¥ª',
            'orange': 'ğŸŠ',
            'broccoli': 'ğŸ¥¦',
            'carrot': 'ğŸ¥•',
            'hot dog': 'ğŸŒ­',
            'pizza': 'ğŸ•',
            'donut': 'ğŸ©',
            'cake': 'ğŸ°',
            'chair': 'ğŸª‘',
            'couch': 'ğŸ›‹ï¸',
            'potted plant': 'ğŸª´',
            'bed': 'ğŸ›ï¸',
            'dining table': 'ğŸ½ï¸',
            'toilet': 'ğŸš½',
            'tv': 'ğŸ“º',
            'laptop': 'ğŸ’»',
            'mouse': 'ğŸ–±ï¸',
            'remote': 'ğŸ“±',
            'keyboard': 'âŒ¨ï¸',
            'cell phone': 'ğŸ“±',
            'microwave': 'ğŸ“Ÿ',
            'oven': 'ğŸ”¥',
            'toaster': 'ğŸ',
            'sink': 'ğŸš°',
            'refrigerator': 'ğŸ§Š',
            'book': 'ğŸ“š',
            'clock': 'ğŸ•',
            'vase': 'ğŸº',
            'scissors': 'âœ‚ï¸',
            'teddy bear': 'ğŸ§¸',
            'hair drier': 'ğŸ’¨',
            'toothbrush': 'ğŸª¥'
        };
        return emojiMap[className] || 'ğŸ“¦';
    }
})();
</script>
</body>
</html>
