<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Water Level Detector</title>
<style>
  body { background:#111; color:#eee; font-family:Arial; text-align:center; }
  video { width:80%; max-width:500px; margin-top:20px; border:3px solid #0ff; }
  #status { margin-top:20px; font-size:20px; }
  .container { position:relative; display:inline-block; margin-top:20px; }
  .water-gauge { 
    width:80px; 
<h2>Water Level Detector</h2>

<div id="status">Starting camera...</div>

<button id="calibrate-btn" style="display:none;">üì∏ Calibrate Empty Pot</button>

<div style="display:flex; justify-content:center; align-items:flex-start; gap:20px; flex-wrap:wrap;">
  <video id="video" autoplay playsinline></video>
  
  <div class="container">
    <div class="water-gauge">
      <div class="gauge-markers">
        <div class="marker" style="top:0%"></div>
        <span class="marker-label" style="top:0%">100%</span>
        <div class="marker" style="top:25%"></div>
        <span class="marker-label" style="top:25%">75%</span>
        <div class="marker" style="top:50%"></div>
        <span class="marker-label" style="top:50%">50%</span>
        <div class="marker" style="top:75%"></div>
        <span class="marker-label" style="top:75%">25%</span>
        <div class="marker" style="top:100%"></div>
        <span class="marker-label" style="top:100%">0%</span>
      </div>
      <div class="water-fill" id="water-fill"></div>
    </div>
    <div id="level" style="font-size:40px; margin-top:10px; color:#0ff;">0%</div>
  </div>
</div>

<canvas id="canvas" style="display:none;"></canvas>

<div style="margin-top:20px;">
  <label style="font-size:18px;">Alert at: 
    <select id="threshold" style="font-size:18px; padding:5px;">
      <option value="80">80%</option>
      <option value="90" selected>90%</option>
      <option value="95">95%</option>
    </select>
  </label>
</div>sition:absolute;
    width:100%;
    height:100%;
    top:0;
    left:0;
  }
  .marker {
    position:absolute;
    width:100%;
    height:1px;
    background:#666;
    left:0;
  }
  .marker-label {
    position:absolute;
    right:90px;
    font-size:12px;
    color:#888;
  }
  #calibrate-btn {
    padding:10px 20px;
    font-size:16px;
    background:#0088ff;
    color:white;
    border:none;
    border-radius:5px;
    cursor:pointer;
    margin-top:20px;
  }
(async () => {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");
    const levelDisplay = document.getElementById("level");
    const waterFill = document.getElementById("water-fill");
    const thresholdSelect = document.getElementById("threshold");
    const calibrateBtn = document.getElementById("calibrate-btn");
    // Start webcam with back camera
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: { ideal: "environment" },
                width: { ideal: 1280 },
                height: { ideal: 720 }
            } 
        });
        video.srcObject = stream;
        status.textContent = "Click 'Calibrate Empty Pot' button to start";
        calibrateBtn.style.display = "inline-block";
    } catch (e) {
        status.textContent = "Camera error: " + e.message;
        return;
    }

    // Calibration button
    calibrateBtn.addEventListener('click', () => {
        const w = video.videoWidth;
        const h = video.videoHeight;
        
        if (!w || !h) {
            status.textContent = "Wait for camera to initialize...";
            return;
        }
        
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);
        
        // Sample larger area for better calibration
        const sampleHeight = Math.floor(h * 0.3);
        const img = ctx.getImageData(0, 0, w, sampleHeight);
        let total = 0;
        
        for (let i = 0; i < img.data.length; i += 4) {
            const r = img.data[i];
            const g = img.data[i + 1];
            const b = img.data[i + 2];
            total += (0.3*r + 0.59*g + 0.11*b);
        }
        
        emptyBrightness = total / (img.data.length / 4);
        fullBrightness = emptyBrightness * 0.4; // Assume full water is ~40% of empty brightness
        
        status.textContent = "‚úì Calibrated! Monitoring water level...";
        calibrateBtn.style.display = "none";
    });bel style="font-size:18px;">Alert at: 
    <select id="threshold" style="font-size:18px; padding:5px;">
      <option value="80">80%</option>
      <option value="90" selected>90%</option>
      <option value="95">95%</option>
    </select>
  </label>
</div>

<script>
(async () => {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");
    const levelDisplay = document.getElementById("level");
    function check() {
        const w = video.videoWidth;
        const h = video.videoHeight;

        if (!w || !h) return requestAnimationFrame(check);

        // Only monitor if calibrated
        if (emptyBrightness === null) {
            requestAnimationFrame(check);
            return;
        }

        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);

        // Sample from top portion to detect water level
        const sampleHeight = Math.floor(h * 0.3);
        const img = ctx.getImageData(0, 0, w, sampleHeight);
        let total = 0;

        for (let i = 0; i < img.data.length; i += 4) {
            const r = img.data[i];
            const g = img.data[i + 1];
            const b = img.data[i + 2];
            total += (0.3*r + 0.59*g + 0.11*b);
        }

        const currentBrightness = total / (img.data.length / 4);
        
        // Add to samples array for smoothing
        samples.push(currentBrightness);
        if (samples.length > 10) samples.shift(); // Keep last 10 samples
        
        // Calculate average of samples for smoother reading
        const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
        
        // Convert brightness to water level percentage using calibrated values
        let waterLevel = ((emptyBrightness - avg) / (emptyBrightness - fullBrightness)) * 100;
        waterLevel = Math.max(0, Math.min(100, waterLevel)); // Clamp between 0-100
        
        const threshold = parseInt(thresholdSelect.value);
        
        // Update display
        levelDisplay.textContent = Math.round(waterLevel) + "%";
        waterFill.style.height = waterLevel + "%";
        
        if (waterLevel >= threshold) {
            status.textContent = "‚ö†Ô∏è WATER LEVEL ALERT!";
            status.style.color = "#ff0000";
            status.style.fontSize = "30px";
            levelDisplay.style.color = "#ff0000";
            waterFill.style.background = "linear-gradient(to top, #ff0000, #ff6600)";
            document.body.style.backgroundColor = "#ff0000";
            
            if (!hasAlarmed) {
                playAlarm();
                hasAlarmed = true;
            }
        } else if (waterLevel >= threshold - 10) {
            status.textContent = "‚ö†Ô∏è Getting close...";
            status.style.color = "#ffaa00";
            status.style.fontSize = "24px";
            levelDisplay.style.color = "#ffaa00";
            waterFill.style.background = "linear-gradient(to top, #ffaa00, #ffdd00)";
            document.body.style.backgroundColor = "#111";
        } else {
            status.textContent = "Monitoring water level";
            status.style.color = "#0f0";
            status.style.fontSize = "20px";
            levelDisplay.style.color = "#0ff";
            waterFill.style.background = "linear-gradient(to top, #00ffff, #0088ff)";
            document.body.style.backgroundColor = "#111";
            hasAlarmed = false; // Reset alarm flag when level drops
        }

        requestAnimationFrame(check);
    }       total += (0.3*r + 0.59*g + 0.11*b);
        }

        const avg = total / (img.data.length / 4);
        
        // Convert brightness to water level percentage (inverted: lower brightness = more water)
        // Calibrate: avg ~150 = 0%, avg ~60 = 100%
        const maxBrightness = 150;
        const minBrightness = 60;
        let waterLevel = ((maxBrightness - avg) / (maxBrightness - minBrightness)) * 100;
        waterLevel = Math.max(0, Math.min(100, waterLevel)); // Clamp between 0-100
        
        const threshold = parseInt(thresholdSelect.value);
        
        // Update display
        levelDisplay.textContent = Math.round(waterLevel) + "%";
        
        if (waterLevel >= threshold) {
            status.textContent = "‚ö†Ô∏è WATER LEVEL ALERT!";
            status.style.color = "#ff0000";
            status.style.fontSize = "30px";
            levelDisplay.style.color = "#ff0000";
            document.body.style.backgroundColor = "#ff0000";
            
            if (!hasAlarmed) {
                playAlarm();
                hasAlarmed = true;
            }
        } else if (waterLevel >= threshold - 10) {
            status.textContent = "‚ö†Ô∏è Getting close...";
            status.style.color = "#ffaa00";
            status.style.fontSize = "24px";
            levelDisplay.style.color = "#ffaa00";
            document.body.style.backgroundColor = "#111";
        } else {
            status.textContent = "Monitoring water level";
            status.style.color = "#0f0";
            status.style.fontSize = "20px";
            levelDisplay.style.color = "#0ff";
            document.body.style.backgroundColor = "#111";
            hasAlarmed = false; // Reset alarm flag when level drops
        }

        requestAnimationFrame(check);
    }

    check();
})();
</script>
</body>
</html>
