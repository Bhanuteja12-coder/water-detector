<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Water Level Detector</title>
<style>
  body { 
    background:#111; 
    color:#eee; 
    font-family:Arial; 
    text-align:center; 
    margin:0;
    padding:20px;
  }
  video { 
    width:80%; 
    max-width:500px; 
    margin-top:20px; 
    border:3px solid #0ff; 
    border-radius:10px;
  }
  #status { 
    margin-top:20px; 
    font-size:20px; 
  }
  .container { 
    position:relative; 
    display:inline-block; 
    margin-top:20px; 
  }
  .water-gauge { 
    width:80px; 
    height:300px; 
    background:#222; 
    border:3px solid #0ff; 
    border-radius:10px;
    position:relative;
    overflow:hidden;
  }
  .water-fill {
    position:absolute;
    bottom:0;
    width:100%;
    background:linear-gradient(to top, #00ffff, #0088ff);
    transition:height 0.3s ease;
    border-radius:0 0 7px 7px;
  }
  .gauge-markers {
    position:absolute;
    width:100%;
    height:100%;
    top:0;
    left:0;
  }
  .marker {
    position:absolute;
    width:100%;
    height:1px;
    background:#666;
    left:0;
  }
  .marker-label {
    position:absolute;
    right:90px;
    font-size:12px;
    color:#888;
  }
  #calibrate-btn {
    padding:10px 20px;
    font-size:16px;
    background:#0088ff;
    color:white;
    border:none;
    border-radius:5px;
    cursor:pointer;
    margin-top:20px;
  }
  #calibrate-btn:hover { 
    background:#0066cc; 
  }
</style>
</head>
<body>
<h2>Water Level Detector</h2>

<div id="status">Starting camera...</div>

<button id="calibrate-btn" style="display:none;">üîÑ Recalibrate</button>

<div style="display:flex; justify-content:center; align-items:flex-start; gap:20px; flex-wrap:wrap;">
  <video id="video" autoplay playsinline></video>
  
  <div class="container">
    <div class="water-gauge">
      <div class="gauge-markers">
        <div class="marker" style="top:0%"></div>
        <span class="marker-label" style="top:0%">100%</span>
        <div class="marker" style="top:25%"></div>
        <span class="marker-label" style="top:25%">75%</span>
        <div class="marker" style="top:50%"></div>
        <span class="marker-label" style="top:50%">50%</span>
        <div class="marker" style="top:75%"></div>
        <span class="marker-label" style="top:75%">25%</span>
        <div class="marker" style="top:100%"></div>
        <span class="marker-label" style="top:100%">0%</span>
      </div>
      <div class="water-fill" id="water-fill"></div>
    </div>
    <div id="level" style="font-size:40px; margin-top:10px; color:#0ff;">0%</div>
  </div>
</div>

<canvas id="canvas" style="display:none;"></canvas>

<div style="margin-top:20px;">
  <label style="font-size:18px;">Alert at: 
    <select id="threshold" style="font-size:18px; padding:5px;">
      <option value="80">80%</option>
      <option value="90" selected>90%</option>
      <option value="95">95%</option>
    </select>
  </label>
</div>

<script>
(async () => {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const status = document.getElementById("status");
    const levelDisplay = document.getElementById("level");
    const waterFill = document.getElementById("water-fill");
    const thresholdSelect = document.getElementById("threshold");
    const calibrateBtn = document.getElementById("calibrate-btn");
    
    let hasAlarmed = false;
    let containerBottom = null; // Y position of container bottom
    let containerTop = null;    // Y position of container top
    let isCalibrated = false;

    // Start webcam with back camera
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: { ideal: "environment" },
                width: { ideal: 1280 },
                height: { ideal: 720 }
            } 
        });
        video.srcObject = stream;
        status.textContent = "STEP 1: Point at EMPTY bottle, click 'Set Empty'";
        calibrateBtn.style.display = "inline-block";
        calibrateBtn.textContent = "1Ô∏è‚É£ Set Empty Bottle";
    } catch (e) {
        status.textContent = "Camera error: " + e.message;
        return;
    }

    let calibrationStep = 0;

    calibrateBtn.addEventListener('click', () => {
        const w = video.videoWidth;
        const h = video.videoHeight;
        
        if (!w || !h) {
            status.textContent = "Wait for camera...";
            return;
        }

        if (calibrationStep === 0) {
            // Step 1: Mark empty bottle (top of container)
            containerTop = detectWaterSurface();
            calibrationStep = 1;
            status.textContent = "STEP 2: Fill bottle to MAX, then click 'Set Full'";
            calibrateBtn.textContent = "2Ô∏è‚É£ Set Full Bottle";
        } else if (calibrationStep === 1) {
            // Step 2: Mark full bottle (bottom reference)
            containerBottom = detectWaterSurface();
            
            if (containerBottom && containerTop && containerBottom > containerTop) {
                isCalibrated = true;
                status.textContent = "‚úì Ready! Fill water and watch percentage";
                status.style.color = "#0f0";
                calibrateBtn.textContent = "üîÑ Restart Calibration";
                calibrationStep = 2;
            } else {
                status.textContent = "ERROR: Make sure full level is below empty. Try again.";
                calibrationStep = 0;
                containerTop = null;
                containerBottom = null;
            }
        } else {
            // Reset calibration
            calibrationStep = 0;
            isCalibrated = false;
            containerTop = null;
            containerBottom = null;
            status.textContent = "STEP 1: Point at EMPTY bottle, click 'Set Empty'";
            status.style.color = "#fff";
            calibrateBtn.textContent = "1Ô∏è‚É£ Set Empty Bottle";
        }
    });

    function detectWaterSurface() {
        const w = video.videoWidth;
        const h = video.videoHeight;
        
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);

        // Scan center vertical line for the biggest brightness change
        const centerX = Math.floor(w / 2);
        let maxChange = 0;
        let surfaceY = h / 2;

        for (let y = Math.floor(h * 0.2); y < Math.floor(h * 0.8); y++) {
            const pixel1 = ctx.getImageData(centerX, y, 1, 1).data;
            const pixel2 = ctx.getImageData(centerX, y + 5, 1, 1).data;
            
            const brightness1 = 0.3 * pixel1[0] + 0.59 * pixel1[1] + 0.11 * pixel1[2];
            const brightness2 = 0.3 * pixel2[0] + 0.59 * pixel2[1] + 0.11 * pixel2[2];
            
            const change = Math.abs(brightness1 - brightness2);
            
            if (change > maxChange) {
                maxChange = change;
                surfaceY = y;
            }
        }

        return surfaceY;
    }

    function playAlarm() {
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(900, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            
            let toggle = true;
            const interval = setInterval(() => {
                oscillator.frequency.setValueAtTime(toggle ? 900 : 1100, audioCtx.currentTime);
                toggle = !toggle;
            }, 400);
            
            setTimeout(() => {
                clearInterval(interval);
                oscillator.stop();
                audioCtx.close();
            }, 5000);
        } catch (e) {
            console.log("Audio error:", e);
        }
    }

    function check() {
        if (!isCalibrated) {
            requestAnimationFrame(check);
            return;
        }

        // Detect current water surface
        const currentSurface = detectWaterSurface();
        
        // Calculate percentage based on position between empty and full
        const totalRange = containerBottom - containerTop;
        const currentFill = currentSurface - containerTop;
        let waterPercentage = (currentFill / totalRange) * 100;
        waterPercentage = Math.max(0, Math.min(100, waterPercentage));
        
        const threshold = parseInt(thresholdSelect.value);
        
        // Update display
        const displayPercent = Math.round(waterPercentage);
        levelDisplay.textContent = displayPercent + "%";
        waterFill.style.height = waterPercentage + "%";
        
        if (waterPercentage >= threshold) {
            status.textContent = "‚ö†Ô∏è ALERT: Water at " + displayPercent + "%!";
            status.style.color = "#ff0000";
            status.style.fontSize = "28px";
            levelDisplay.style.color = "#ff0000";
            waterFill.style.background = "linear-gradient(to top, #ff0000, #ff6600)";
            document.body.style.backgroundColor = "#330000";
            
            if (!hasAlarmed) {
                playAlarm();
                hasAlarmed = true;
            }
        } else if (waterPercentage >= threshold - 15) {
            status.textContent = "Warning: " + displayPercent + "% (close to " + threshold + "%)";
            status.style.color = "#ffaa00";
            status.style.fontSize = "22px";
            levelDisplay.style.color = "#ffaa00";
            waterFill.style.background = "linear-gradient(to top, #ffaa00, #ffdd00)";
            document.body.style.backgroundColor = "#111";
            hasAlarmed = false;
        } else {
            status.textContent = "Water Level: " + displayPercent + "%";
            status.style.color = "#0f0";
            status.style.fontSize = "20px";
            levelDisplay.style.color = "#0ff";
            waterFill.style.background = "linear-gradient(to top, #00ffff, #0088ff)";
            document.body.style.backgroundColor = "#111";
            hasAlarmed = false;
        }

        requestAnimationFrame(check);
    }

    check();
})();
</script>
</body>
</html>
